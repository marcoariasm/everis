Angular 11
Typescript
Git GitHub
12 proyectos de Angular

Instalaciones necesarias:
    Google chrome
    Visual Studio Code
    Postman
    Mongo Compass
    Git + cuenta en github
    Node

Extensiones VS Code:
    angular snippets
    angular language service
    angular inline
    auto close tag
    typescript importer



start-process PowerShell -verb runas

5  Instalar Angular CLI
    npm i -g @angular/cli



PORQUÉ ANGULAR USA Typescript
- por la ayuda y un intellisense fuerte
- por el tipado estricto y errores en el momento de la escritura
- permite la inyección de dependencias (disponer de clases desde cualquier lugar de la aplicación)


MITOS
- Solucion a SEO Friendly:  hacer SSR con Angular Universal




ANGULAR
=======
- Marco de trabajo estandarizado
- vienen con todo lo que necesitas para trabajar
- es modular
- google le da mantenimiento hoy en día
- servicios en Angular son singleton bastante fuertes y centralizados


GIT RELEASE TAG
git tag -a v0.1.0 -m "fin seccion 4"
git push
git push --tag
(editar release en GitHub)
(ya se puede descargar la versión)



CREAR MÓDULO

 ng g m dbz

 ng g c dbz/mainPage --skipTests

 ng g c dbz/personajes --skipTests

 
[60]
pasar info del componente padre al hijo

[61]
Tarea con inputs y módulos
  1. nuevo componente     agregar           ng g c dbz/nuevo --skipTests
  2. <h3> Agregar ... hasta... </form>      
  3. Mover nuevo, agregar()
  4. @Input  personajes
  5. @Input  nuevo
  6. <app-agregar [nuevo]="nuevo">

[62]
outputs y eventemitter

[63]
depuraciones en chrome  F5  environment: Chrome,  generar un breakpoint

[64]
servicios en Angular hace que no se requiera de redux
son singletons muy poderosos

crear un servicio
  services/dbz.service.ts


[72]  Seccion 7
  - Modularización de la aplicación
  - estructura de la aplicación de media a gran escala 
  - componentes
  - viewchild
  - servicios
  - historial de búsquedas
  - uso de api keys
  - local y  sessionstorage
  - peticiones HTTP
  - animaciones mediante CSS

  APLICACION DE BANCO DE IMAGENES GIF

1 Crear  modulo shared
2 crear component  sidebar
3 exportar el sidebar en el módulo
4 importar el shared.modulo  dentro del app.module.ts
5 colocar el componente  <app-sidebar>


ng g c gifs/gifPage --skipTests -is


ng g s gifs/services/gif --skipTests



[95]

modularizar la aplicación
carpeta principal  Pais    es un módulo
	agrupa  components
		interfaces
		pages
		services

ng g m shared
ng g m pais

** revertir borrado de componentes


ng g c pais/pages/porCapital --skip-tests -is
ng g c pais/pages/porPais --skip-tests -is
ng g c pais/pages/porRegion --skip-tests -is
ng g c pais/pages/verPais --skip-tests -is

exportar sidebar  en el   shared.module.ts




https://restcountries.eu/rest/v2/name/united


[103]
ng g s pais/services/pais --skip-tests

[107]

1   pais-tabla.componente.ts
  /pais/components/pais-tabla

2   HTML=   <table></table>

3   por-pais  component
    <app-pais-tabla></..>

4   @Input() paises: Country[] = [ ]

ng g c pais/paisInput --skip-tests -is

[109]

Debounce time:
Se usa cuando en una caja de busqueda se escribe unas letras y se espera un poco y se hace una llamada automatica a la busqueda para conectarse
y traer la info sin necesidad de presionar enter


[110]

Por capital: hacerlo funcionar


[126]  * * * * Sección 10: PIPES * * * *

npm i primeng primeicons --save

[131]

1. Instalar primeng  y primeicons
2. importar estilos en   angular.json   styles
   importar estilos del   vela-blue
3.  importar  ButtonModule  y CardModule  y  llamarlos de manera simplificada
    crear estilos globales  simples pero utilizando  las variables globales de  vela-blue
4.  Crear modulo centralizado  para consumir  los componentes de  primeng
    ahí se importarán los componentes de PrimeNg y estarán a disposición de toda la app

    ng g m primeNg
5.  crear carpetas:
    shared,  (colocar un modulo aqui y en ventas)
    ventas >   interfaces,pages,pipes

6.  ng g c shared/menu --skip-tests -is

    exponer ese c menu a disposición del modulo shared



[214] 15. Proteccion de Rutas

ng g guard auth/guards/auth --skip-tests   
  can activate   y  can load


recomendable usar ambos  can activate y   can load  a la vez
por un tema de seguridad

[226] 16. Formularios
1. crear módulo  shared  
    ng g m shared --skip-tests -is

2. crear 2 modulos routing
    ng g m template --routing
    ng g m reactive --routing

  borrar sus exports

3. crear componentes
    ng g c reactive/basicos --skip-tests -is
                   /dinamicos
                   /switches

    en el archivo app-routing.module.ts  hacer los respectivos lazyload

  { path: 'template', 
    loadChildren: () => import('./template/template.module').then( m => m.TemplateModule )
  },

5. diseñar el sidemenu  con sus items en forma de lista como tabla de bootstrap
     li   +  routerLink="templates/basicos"

   crear interface en  sidemenu.component   que contenga     ruta y texto
   usar *ngFor  para pintar el  templateMenu   no olvidar usar
      routerLinkActive

6. Formulario por
   template:  que angular se encargue de manera automática del lado del HTML
   reactivos:  que la parte más pesada la tengamos en el lado de typescript

   Crear el formulario con bootstrap  en el  template  html  respectivo

7. import  FormsModule    en    el template.module
   *  el botón de  Guardar   ya no refresca el formulario,  ya Angular tomó el control del formu  lario

8.  referencio y creo  funcion guardar
    <form #miFormulario="ngForm" (ngSubmit)="guardar(miFormulario)">

    en cada input  agrego las propiedades   NgModel  y   name="..."   para mostrarlo en el modelo de formulario

9. artificio para ver el cambio de valores en los inputs

<div class="row">
    <div class="col">
        <span>Valid</span>
        <pre>{{ miFormulario.valid }}</pre>

        <span>Valor</span>
        <pre>{{ miFormulario.value | json }}</pre>
    </div>
</div>

  de esta forma  puedo agregar en cada  input    ->  required
  y si además es número  puedo poner    min="0"

10.  en el span de error validar con un  *ngIf
            *ngIf="miFormulario.form.controls.producto?.invalid && 
                   miFormulario.form.controls.producto?.touched"

11. simplifico la funcion de validacion de *ngIf
    en el   basicos.component   creo un  @viewchild que referencie a #miFormulario

            @ViewChild('miFormulario') miFormulario!: NgForm; 

    crear un método donde encapsule la validacion

            nombreValido(): boolean {
              return this.miFormulario?.form.controls.producto?.invalid && 
                   this.miFormulario?.form.controls.producto?.touched
            }
    
    igualmente para precio y para existencias

12. para el botón agregamos un método:
    [disabled] = "miFormulario.invalid"

    verificar las validaciones

[235] DIRECTIVAS
se debe trabajar una nueva directiva en el campo existencias
   hay que considerar:
    - immportar esa directiva en el modulo respectivo en   Declarations
    - poner un valor minimo   como Input
    - validar que sea requerido
    - implements   Validator


[236] limpiar el formulario




[246] FORMULARIOS * * REACTIVOS * *  reactive > basicos
      - Simplificamos el html de  reactivos >  basicos, dinamicos y switches   (copiado de template)
      - Debe quedar un html limpio sin errores con     input → type,  class,  placeholder
      - En el módulo respectivo (reactive)   importar  ReactiveFormsModule
      - vincular cada campo html  con su etiqueta, ej:    formControlName = "nombre"    y en ts:

                    miFormulario: FormGroup = new FormGroup({
                      'nombre': new FormControl('RTX 4080ti'),
                      'precio': new FormControl(800),
                      'existencias': new FormControl(15)
                    })  
      
      - las validaciones se hacen en el el  .ts  ya no en el  .html
      - new FormArray([])   agrupa  FormControl s
      - pero usaremos el  FormBuilder  que es un servicio por lo tanto se inyecta en el 
            constructor ( private fb: FormBuilder ) {}
      - ej:
                  miFormulario: FormGroup = this.fb.group({
                    nombre     : [ 'RTX 4080ti' ],
                    precio     : [800],
                    existencias: [15]
                  })

      - para las  * validaciones * , hay validadores síncronos y asíncronos
        si se agrupan usarlos como arreglo simplemente, ej

                  nombre     : [ 'RTX 4080ti', [Validators.required, Validators.minLength(3)] ],
                
        si hay que validar un botón, en su   .html

                  [disabled]="miFormulario.invalid"

      - para los  * msjs de error * 
        creo una función en .ts

                campoEsValido(campo: string) {
                  return this.miFormulario.controls[campo].errors
                        && this.miFormulario.controls[campo].touched
                }

        en el .html   uso esa función en el span de msj error

                *ngIf="campoEsValido('nombre')

        se podría jugar con el msj de error según el tipo de error  (prueba)

                // campoEsCero(campo: string) {
                //   return this.miFormulario.controls[campo].errors!.min.min == 0
                // }

      - para el envío de los datos  * submit *
        borrar el disabled del botón y poner en    form     (ngSubmit)="guardar()"
        
        para mostrar errores si se envia el formulario presionando   Guardar  y
        para resetear el form y poner los valores en 0 al ser enviado

      - para setear  valores al inicio del formulario:

                ngOnInit() {
                  this.miFormulario.reset({
                    nombre: 'RTX 44080ti',
                    precio: 1600  //  notese que falta existencias y aun asi el form NO REVENTÓ!!!
                  })
                }

[252]  * Formularios dinámicos  REACTIVOS *
      - Simplificamos el html de  reactivos >  basicos, dinamicos y switches   (copiado de template)
      - Debe quedar un html limpio sin errores con     input → type,  class,  placeholder
      - En el módulo respectivo (reactive)   importar  ReactiveFormsModule



[339] 23.  DIRECTIVAS PERSONALIZADAS
Para añadir estilos a html o tb existen directivas estructurales
Aqui se verá una directiva para manejar msjs de error en formularios reactivos

ennlaces:   bootstrap CSS
            angular.io   attribute directives

0.  ng new angularPipes

1.  importar css bootstrap en  index.html
    levantar el proyecto     npm start    (ng serve --o)

2.  crear  carpetas:      productos  ( * * aquí se va a usar  lazyload * * )
                          shared

    ng g m productos --routing
    ng g m shared

3.  crear componentes   pages/agregar

    ng g c pages/agregar --skip-tests -is

